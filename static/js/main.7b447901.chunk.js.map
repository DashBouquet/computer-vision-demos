{"version":3,"sources":["models/classifier.js","models/frozen.js","App.js","serviceWorker.js","index.js"],"names":["ClassifierApi","config","Object","classCallCheck","this","hostname","useMobileNet","mobilenet","classifier","modelName","loadMobileNet","loadClassifier","tf","listModels","modelsInfo","console","log","keys","length","filter","modelPath","includes","split","dispose","fetchModel","layer","getLayer","inputs","outputs","output","Error","_context3","t0","model","_context4","idbModelExists","concat","save","then","catch","err","warn","imageData","normalizeImage","input","predict","predictedClass","webcamImage","_this","cropImage","expandDims","toFloat","div","sub","img","size","Math","min","shape","beginHeight","beginWidth","slice","_this2","as1D","data","palmConfidence","Frozen","ASSETS_URL","MODEL_URL","WEIGHTS_URL","IMAGE_SIZE","labels","loadFrozenModel","executeAsync","performance","now","image","resized","resizeBilinear","offset","normalized","predictions","map","label","index","accuracy","sort","a","b","time","toFixed","loadModel","toPercent","score","App","possibleConstructorReturn","getPrototypeOf","call","handleKeyPress","event","listenKeys","saveSnaps","key","handleKeyPressUp","snapsPerSecond","predictionsPerSecond","predictionQueueCap","state","gestIndex","predIndex","gestureLoading","gestureLast","Date","snapLast","snapsInProcessing","snapShot","bind","assertThisInitialized","classifyBox","video","cnv","_ref","window","innerWidth","innerHeight","width","height","webcamRatio","videoWidth","videoHeight","style","top","left","stream","document","createElement","srcObject","display","body","appendChild","onloadedmetadata","e","setup","cvs","play","ctx","updateDetectBoxes","requestAnimationFrame","_this3","classifyImage","outCnv","res","setState","boxSize","drawImage","strokeStyle","lineWidth","rect","stroke","outCtx","navigator","mediaDevices","getUserMedia","Promise","reject","_this4","_ref2","getContext","addEventListener","captureWebcam","objectUrl","webCamLoaded","_this5","frozen","init","_this6","_this7","detections","Array","from","react_default","Fragment","className","v","i","backgroundColor","whiteSpace","tabIndex","ref","Component","Boolean","location","match","ReactDOM","render","src_App_0","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.7b447901.chunk.js","sourcesContent":["import * as tf from '@tensorflow/tfjs';\n\nclass ClassifierApi {\n  constructor(config) {\n    this.hostname = config.hostname;\n    this.useMobileNet = config.useMobileNet;\n    this.mobilenet = false;\n    this.classifier = false;\n  }\n  async loadModel(modelName) {\n    if (this.useMobileNet) await this.loadMobileNet();\n    await this.loadClassifier(modelName);\n  }\n\n  async idbModelExists(modelName) {\n    const modelsInfo = await tf.io.listModels();\n    console.log(Object.keys(modelsInfo));\n    if (Object.keys(modelsInfo).length === 0) return false;\n\n    return (\n      Object.keys(modelsInfo).filter((modelPath) => {\n        return (\n          modelPath.includes('indexeddb') &&\n          modelPath.split('://')[1] === modelName\n        );\n      }).length > 0\n    );\n  }\n\n  async loadMobileNet() {\n    try {\n      if (this.mobilenet) this.mobilenet.dispose();\n\n      const mobilenet = await this.fetchModel('mobileNet');\n      const layer = mobilenet.getLayer('conv_pw_13_relu');\n      this.mobilenet = tf.model({\n        inputs: mobilenet.inputs,\n        outputs: layer.output\n      });\n\n      console.log('mobileNet loaded');\n    } catch (e) {\n      throw new Error(e);\n    }\n  }\n\n  async loadClassifier(modelName) {\n    try {\n      const model = await this.fetchModel(modelName);\n      this.classifier = model;\n      console.log('classifier loaded');\n    } catch (e) {\n      throw new Error(e);\n    }\n  }\n\n  async fetchModel(modelName) {\n    const modelExists = await this.idbModelExists(modelName);\n\n    if (modelExists) {\n      console.log(`Loading ${modelName} from IDB`);\n      const model = await tf.loadModel(`indexeddb://${modelName}`);\n      return model;\n    } else {\n      console.log(`Loading ${modelName} from local server`);\n      const model = await tf.loadModel(\n        `${this.hostname}/${modelName}/model.json`\n      );\n\n      model\n        .save(`indexeddb://${modelName}`)\n        .then(() => console.log(`${modelName} saved to IDB`))\n        .catch((err) => console.warn(err));\n      return model;\n    }\n  }\n\n  async classifyImage(imageData) {\n    if (!this.classifier || (this.useMobileNet && !this.mobilenet))\n      return false;\n\n    let input = await this.normalizeImage(imageData);\n\n    const predictedClass = await this.predict(input);\n    return predictedClass;\n  }\n\n  async normalizeImage(imageData) {\n    return tf.tidy(() => {\n      const webcamImage = tf.fromPixels(imageData);\n      const croppedImage = this.cropImage(webcamImage);\n\n      const batchedImage = croppedImage.expandDims(0);\n\n      return batchedImage\n        .toFloat()\n        .div(tf.scalar(127))\n        .sub(tf.scalar(1));\n    });\n  }\n\n  cropImage(img) {\n    const size = Math.min(img.shape[0], img.shape[1]);\n    const centerHeight = img.shape[0] / 2;\n    const beginHeight = centerHeight - size / 2;\n    const centerWidth = img.shape[1] / 2;\n    const beginWidth = centerWidth - size / 2;\n    return img.slice([beginHeight, beginWidth, 0], [size, size, 3]);\n  }\n\n  async predict(input) {\n    const predictedClass = tf.tidy(() => {\n      if (this.useMobileNet) input = this.mobilenet.predict(input);\n      const predictions = this.classifier.predict(input);\n\n      return predictions.as1D();\n    });\n\n    let palmConfidence = await predictedClass.data();\n    predictedClass.dispose();\n\n    return palmConfidence;\n  }\n}\n\nexport default ClassifierApi;\n","import * as tf from '@tensorflow/tfjs';\nimport { loadFrozenModel } from '@tensorflow/tfjs-converter';\n\nclass Frozen {\n  constructor() {\n    this.ASSETS_URL = `http://127.0.0.1:8085/nnModels/`;\n    this.MODEL_URL = `${\n      this.ASSETS_URL\n    }/converted-sessionmodel/tensorflowjs_model.pb`;\n    this.WEIGHTS_URL = `${\n      this.ASSETS_URL\n    }/converted-sessionmodel/weights_manifest.json`;\n    this.IMAGE_SIZE = 224;\n    this.labels = ['closed', 'opened'];\n    this.model = false;\n  }\n\n  async loadModel() {\n    const model = await loadFrozenModel(this.MODEL_URL, this.WEIGHTS_URL);\n    // Warm up GPU\n    const input = tf.zeros([1, this.IMAGE_SIZE, this.IMAGE_SIZE, 3]);\n    await model.executeAsync({ input }); // MobileNet V1\n    //model.predict({ Placeholder: input }) // MobileNet V2\n\n    return model;\n  }\n\n  async classifyImage(img) {\n    const t0 = performance.now();\n    const image = tf.fromPixels(img).toFloat();\n    const resized = tf.image.resizeBilinear(image, [\n      this.IMAGE_SIZE,\n      this.IMAGE_SIZE\n    ]);\n    const offset = tf.scalar(255 / 2);\n    const normalized = resized.sub(offset).div(offset);\n    const input = normalized.expandDims(0);\n    const output = await tf.tidy(() => this.model.predict({ input })).data(); // MobileNet V1\n    //const output = await tf.tidy(() => this.model.predict({ Placeholder: input })).data() // MobileNet V2\n    const predictions = this.labels\n      .map((label, index) => ({ label, accuracy: output[index] }))\n      .sort((a, b) => b.accuracy - a.accuracy);\n    const time = `${(performance.now() - t0).toFixed(1)} ms`;\n    return { predictions, time };\n  }\n\n  async init() {\n    this.model = await this.loadModel();\n    //const predictions = await this.predict(input)\n    //console.log(predictions)\n  }\n}\nexport default Frozen;\n","import React, { Component } from 'react';\nimport { createTrainImage } from './models/requests';\nimport ClassifierApi from './models/classifier';\nimport Frozen from './models/frozen';\nimport './App.css';\n\nconst toPercent = (score) => (score * 100).toFixed(2);\n\nclass App extends Component {\n  constructor() {\n    super();\n\n    // Config\n    this.snapsPerSecond = 3;\n    this.predictionsPerSecond = 10;\n    this.predictionQueueCap = 5;\n    this.listenKeys = true;\n\n    this.state = {\n      classifier: false,\n      gestIndex: 0,\n      predIndex: []\n    };\n\n    this.gestureLoading = false;\n    this.gestureLast = Date.now();\n    this.snapLast = Date.now();\n    this.saveSnaps = null;\n    this.snapsInProcessing = 0;\n\n    this.snapShot = this.snapShot.bind(this);\n    this.classifyBox = this.classifyBox.bind(this);\n  }\n\n  setup(video, cnv) {\n    const [width, height] = [window.innerWidth, window.innerHeight];\n    const webcamRatio = video.videoWidth / video.videoHeight;\n    const aspectRatio = width / height;\n\n    if (webcamRatio > aspectRatio) {\n      cnv.width = width;\n      cnv.height = width / webcamRatio;\n      cnv.style.top = 0 - (cnv.height / 2 - height / 2);\n    } else {\n      cnv.height = height;\n      cnv.width = height * webcamRatio;\n      cnv.style.left = 0 - (cnv.width / 2 - width / 2);\n    }\n  }\n\n  webCamLoaded(stream) {\n    this.video = document.createElement('video');\n    this.video.srcObject = stream;\n    this.video.style.display = 'none';\n    document.body.appendChild(this.video);\n\n    this.video.onloadedmetadata = (e) => {\n      this.setup(this.video, this.cvs);\n      this.video.play();\n      this.snapShot();\n    };\n  }\n\n  async snapShot() {\n    if (this.ctx) {\n      this.updateDetectBoxes();\n      if (this.state.classifier) {\n        this.classifyBox();\n      }\n    }\n\n    requestAnimationFrame(this.snapShot);\n  }\n\n  printScore(score) {\n    console.log(\n      `%c${(score * 100).toFixed(2)}% (${this.snapsInProcessing})`,\n      'margin-left: 15px; color: blue; font-size:15px; background: white; padding: 5px; border-radius: 5px;'\n    );\n  }\n\n  classifyBox() {\n    if (\n      !this.gestureLoading &&\n      Date.now() - this.gestureLast > 1000 / this.predictionsPerSecond &&\n      this.snapsInProcessing < this.predictionQueueCap\n    ) {\n      this.snapsInProcessing++;\n      this.gestureLoading = true;\n      this.gestureLast = Date.now();\n      this.state.classifier.classifyImage(this.outCnv).then((res) => {\n        this.snapsInProcessing--;\n        this.gestureLoading = false;\n        this.setState({ predIndex: res });\n        //this.printScore(res);\n        // const idx = res > 0.5 ? 1 : 0;\n\n        // if (\n        //   this.saveSnaps !== null &&\n        //   Date.now() - this.snapLast > 1000 / this.snapsPerSecond\n        // ) {\n        //   const b64 = this.outCnv.toDataURL('image/jpeg');\n\n        //   const imageData = {\n        //     data: b64,\n        //     class: this.saveSnaps\n        //   };\n        //   createTrainImage(imageData);\n        //   this.snapLast = Date.now();\n        // }\n\n        // this.setState({ gestIndex: idx });\n      });\n    }\n  }\n\n  updateDetectBoxes() {\n    const boxSize = window.innerHeight / 2;\n    const border = 5;\n    this.ctx.drawImage(this.video, 0, 0, this.cvs.width, this.cvs.height);\n\n    this.ctx.strokeStyle = '#0F0';\n    this.ctx.lineWidth = border;\n    this.ctx.rect(\n      (this.cvs.width - boxSize - border) / 2,\n      (this.cvs.height - boxSize - border) / 2,\n      boxSize + border,\n      boxSize + border\n    );\n    this.ctx.stroke();\n\n    this.outCtx.drawImage(\n      this.cvs,\n      (this.cvs.width - boxSize) / 2,\n      (this.cvs.height - boxSize) / 2,\n      boxSize,\n      boxSize,\n      0,\n      0,\n      224,\n      224\n    );\n  }\n\n  captureWebcam() {\n    if (navigator.mediaDevices) {\n      return navigator.mediaDevices\n        .getUserMedia({ video: true })\n        .then((stream) => stream);\n    } else {\n      return Promise.reject(\n        new Error(\n          'Native web camera streaming (getUserMedia) not supported in this browser.'\n        )\n      );\n    }\n  }\n\n  handleKeyPress = (event) => {\n    if (this.listenKeys && this.saveSnaps !== event.key) {\n      this.saveSnaps = event.key;\n      console.log(`Saving images of ${event.key} class`);\n    }\n  };\n\n  handleKeyPressUp = (event) => {\n    this.saveSnaps = null;\n  };\n\n  componentDidMount() {\n    [this.cvs.width, this.cvs.height] = [window.innerWidth, window.innerHeight];\n    this.ctx = this.cvs.getContext('2d');\n\n    document.body.addEventListener('keydown', this.handleKeyPress, false);\n    document.body.addEventListener('keyup', this.handleKeyPressUp, false);\n\n    this.loadClassifier();\n\n    this.captureWebcam().then((objectUrl) => {\n      this.webCamLoaded(objectUrl);\n    });\n\n    this.outCtx = this.outCnv.getContext('2d');\n  }\n\n  loadFrozen() {\n    const frozen = new Frozen();\n    frozen.init().then(() => {\n      this.setState({ classifier: frozen });\n    });\n  }\n\n  loadClassifier() {\n    const classifier = new ClassifierApi({\n      hostname: 'https://dashbouquet.github.io/computer-vision-demos/models/',\n      useMobileNet: false\n    });\n\n    classifier\n      .loadModel('hands2-93-0.9880')\n      .then(() => {\n        console.warn('READY TO CLASSIFY');\n        this.setState({ classifier });\n      })\n      .catch((e) => {\n        console.log(e);\n      });\n  }\n\n  render() {\n    const detections = Array.from(this.state.predIndex) || [];\n    //const labels = ['0','1','2','3','4','5','6','7','8','9','q','w','x','z'];\n    const labels = ['close', 'open'];\n    return (\n      <React.Fragment>\n        {this.state.gestIndex === 1 ? (\n          <p className=\"palmDetected\">PALM</p>\n        ) : null}\n          <div className=\"statsTable\">\n            {detections.map((v, i) => (<div><div style={{width: `${toPercent(v)}%`, backgroundColor: 'green', whiteSpace: 'nowrap'}}>{labels[i]} {toPercent(v)}%</div></div>))}\n          </div>\n        <canvas\n          tabIndex=\"0\"\n          key={'cvsMain'}\n          className=\"canvas\"\n          ref={(cvs) => {\n            this.cvs = cvs;\n          }}\n        />\n        <canvas\n          key={'cvsSecondary'}\n          className=\"tmpCanvas\"\n          ref={(outCnv) => {\n            this.outCnv = outCnv;\n          }}\n          width=\"224\"\n          height=\"224\"\n        />\n      </React.Fragment>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport './index.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}